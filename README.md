## EC311-Project
### By Team Combinational Magic, Aymeric Blaizot, Thomas Young, Tom Barrette, Connor Casey
# Tilt
A maze solving game using tilt controls. The user will have to navigate an ever changing maze and reach the flag to increase score in the alloted time.
Youtube Link: https://youtu.be/FpAGFjh3B7s
## Features

### Accelerometer Motion Controls (Connor)
  We used the ADXL362 accelerometer on board the FPGA to control motion of the ball. This requires both an SPI Master and SPI Interface, but also a denoiser and decoder for the accelerometer.

  When the FPGA is tilted or moved at varying degrees this is reflected in the movement of the ball on screen. It works in all directions and also has deadzones to allow for more precise movement. It does this by adding the X and Y data from the Accelerometer to the Balls position on the screen.

  The modules responsible for this are spimaster.v, which contains the FSM for the accelerometer, iclk.v, which contains the serial clock generator, and snippets in VGA_Map, which use the movement data in order to move the ball.

### Maze Generation (Thomas Y.)
  The map for Tilt is generated by first taking the user inputted overall map size (400x400, 420x420, etc.) and grid amount (4x4, 7,7 etc.) and generates the requested map. The grid sizes are created as a function of the requested map size, thus creating dynamic grids that users can tweak.

The end flag is also programmed as a function of the grid sizes, ensuring that the flag is always centered in the top right grid.

### Collision Detection (Tom B)
It is important to prevent the player from simply moving through the walls of the maze, so collision algorithms were necessary in order to determine when and how to limit the player's movement. For the "hard mode" version of the maze, the player reset to the start of the maze whenever they collided with a wall. Therefore, we only needed to check if any kind of collision (intersection between player and another object) had occurred without considering the direction of the collision. This was accomplished using an edge/rectangle detection algorithm for the outer walls of the maze and a for loop combined with a rectangle/rectangle collision detection algorithm for all the inner walls. For the "easy mode" version of the maze, we wanted the wall to stop the player's movement perpendicular to the wall but allow the player to slide parallel to the wall. This required us to split the collision detection into x and y components. We also altered our algorithm to detect whether the player's next position (x+vx, y+vy) would result in a collision, and prevent movement in the correct direction.

VGA_Map.v

### Random Maze Generation (Aymeric)
  The vertical and horiztonal lines of the maze are modulated by two differently clocked linear-feedback shift registers (LFSR) and sampled every second to change the maze every second. This happens independently for each horizontal and vertical line segment.  

VGA_Map

### Timer and Score counter (Aymeric)
The player has set number of seconds to reach the flag that is equal to the number of grids on the maze (shown on the seven segment display). The display also records the number of times the player has reached the end of the maze.

### Hard Mode (Aymeric)
A switch on the Nexys board makes collision with any wall reset to the begining of the maze.

## Overview of the code structure


## How to Run
Add all files in either Final_with_multiple_modes or the Final folder as design sources. Set the top to as top_lines_mov.v. Add the Nexys4DDR_Master_lines.xdc as a constraints file. Run synthesis, implemementation, generate bitstream, and program the device. Connect Nexys 4 to VGA and enjoy.

